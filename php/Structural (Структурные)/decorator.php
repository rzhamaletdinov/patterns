<?php
/**
 * Декоратор (Decorator) — предназначен для динамического подключения
 * дополнительного поведения к объекту.
 * Шаблон Декоратор предоставляет гибкую альтернативу
 * практике создания подклассов с целью расширения функциональности.
 *
 * *************Задача
 * Объект, который предполагается использовать,
 * выполняет основные функции.
 * Однако может потребоваться добавить к нему некоторую дополнительную функциональность,
 * которая будет выполняться до,
 * после или даже вместо основной функциональности объекта.
 *
 * *************Способ решения
 * Декоратор предусматривает расширение функциональности объекта без определения подклассов.
 *
 * *************Участники
 * ConcreteComponent — класс, в который с помощью шаблона Декоратор добавляется новая функциональность.
 * В некоторых случаях базовая функциональность предоставляется классами,
 * производными от класса ConcreteComponent.
 * В подобных случаях класс ConcreteComponent является уже не конкретным, а абстрактным.
 * Абстрактный класс Component определяет интерфейс для использования всех этих классов.
 *
 * *************Следствия
 * 1.   Добавляемая функциональность реализуется в небольших объектах.
 *      Преимущество состоит в возможности динамически добавлять эту функциональность
 *      до или после основной функциональности объекта ConcreteComponent.
 * 2.   Позволяет избегать перегрузки функциональными классами на верхних уровнях иерархии
 * 3.   Декоратор и его компоненты не являются идентичными
 *
 * *************Реализация
 * Создается абстрактный класс, представляющий как исходный класс,
 * так и новые, добавляемые в класс функции.
 * В классах-декораторах новые функции вызываются в требуемой последовательности —
 * до или после вызова последующего объекта.
 * При желании остаётся возможность использовать исходный класс (без расширения функциональности),
 * если на его объект сохранилась ссылка.
 *
 * *************Замечания и комментарии
 * Хотя объект-декоратор может добавлять свою функциональность до или после функциональности основного объекта,
 * цепочка создаваемых объектов всегда должна заканчиваться объектом класса ConcreteComponent.
 * И декоратор, и адаптер являются обертками вокруг объекта —
 * хранят в себе ссылку на оборачиваемый объект и часто передают в него вызовы методов.
 * Отличие декоратора от адаптера в том,
 * что адаптер имеет внешний интерфейс,
 * отличный от интерфейса оборачиваемого объекта,
 * и используется именно для стыковки разных интерфейсов.
 * Декоратор же имеет точно такой же интерфейс,
 * и используется для добавления функциональности.
 * Для расширения функциональности класса возможно использовать как декораторы,
 * так и стратегии.
 * Декораторы оборачивают объект снаружи,
 * стратегии же вставляются в него внутрь по неким интерфейсам.
 * Недостаток стратегии: класс должен быть спроектирован с возможностью вставления стратегий,
 * декоратор же не требует такой поддержки.
 * Недостаток декоратора: он оборачивает ровно тот же интерфейс,
 * что предназначен для внешнего мира,
 * что вызывает смешение публичного интерфейса и интерфейса кастомизации,
 * которое не всегда желательно.
 */

class Pattern
{
    static function process()
    {
        $decoratedComponent = new ConcreteDecorator(
            new ConcreteComponent()
        );

        $decoratedComponent->operation();
    }
}

interface Operation
{
    public function operation();
}

abstract class AbstractComponent implements Operation{
    abstract public function operation();
}

class ConcreteComponent extends AbstractComponent {
    public function operation() {
        print ("Component: Opertaion \n");
    }
}

abstract class AbstractDecorator extends AbstractComponent {
    protected $_component;

    public function __construct(AbstractComponent $component) {
        $this->_component = $component;
    }
}

class ConcreteDecorator extends AbstractDecorator {
    public function operation() {
        print ("Decorator: Before Opertaion \n");
        $this->_component->operation();
        print ("Decorator: After Opertaion \n");
    }
}
Pattern::process();