/************************************
Adapter (Адаптер)
-------------------------------------
Если есть класс, который выполняет требуемую задачу, но не имеет нужный интерфейс
Оборачиваем его в новый класс-адаптер,
с методами, соответствующими интерфейсу.
И внутри приведя данные к нужному старому виду
делегируем обработку старому классу

старый объект заталкиваем в private переменную

/************************************
Bridge (Мост)
-------------------------------------
Для работы с группой одинаковых сущностей,
различающихся (и ИЗМЕНЯЮЩИХСЯ под новые требования) по реализации.

Делаем общий интерфейс для реализции.
Описываем классы с конкретной реализацией поведения.
Далее при создании конкретных классов сущностей
принимаем в конструктор класс-реализатор интерфейса и храним его в protected переменной
делаем метод, делегирующий, реализацию конкретно этому классу-реализатору

в итоге выбор реализации делается передачей в конструктор нужного класса-реализатора при инициализации объекта
вызов реализации идентичен для всех объектов

/************************************
Composite (Компановщик)
-------------------------------------

/************************************
Decorator (Декоратор)
-------------------------------------

/************************************
Facade (Фасад)
-------------------------------------

/************************************
Flyweight (Приспособленец)
-------------------------------------

/************************************
Proxy (Заместитель)
-------------------------------------
