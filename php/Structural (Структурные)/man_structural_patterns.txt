/************************************
Adapter (Адаптер)
-------------------------------------
Если есть класс, который выполняет требуемую задачу, но не имеет нужный интерфейс
Оборачиваем его в новый класс-адаптер,
с методами, соответствующими интерфейсу.
И внутри приведя данные к нужному старому виду
делегируем обработку старому классу

старый объект заталкиваем в private переменную

/************************************
Bridge (Мост)
-------------------------------------
Для работы с группой одинаковых сущностей,
различающихся (и ИЗМЕНЯЮЩИХСЯ под новые требования) по реализации.

Делаем общий интерфейс для реализции.
Описываем классы с конкретной реализацией поведения.
Далее при создании конкретных классов сущностей
принимаем в конструктор класс-реализатор интерфейса и храним его в protected переменной
делаем метод, делегирующий, реализацию конкретно этому классу-реализатору

в итоге выбор реализации делается передачей в конструктор нужного класса-реализатора при инициализации объекта
вызов реализации идентичен для всех объектов

/************************************
Composite (Компановщик)
-------------------------------------
Для управления оч сложными объектами

Делаем объект древовидной структуры произвольной вложенности,
состоящий из двух компонентов
(Composite  - имеющий child_objects
 Leaf       - не имеющий вложенных объектов(хотя можно обойтись одним,
 считая все объекты Composite, где child_objects == 0 объектом Leaf))
Оба наследуются от AutoObject
его интерфес определяет интерфейс всех объектов:
методы add, remove, get_child, get_iterator
итератор работает рекурсивно, т.е.
при переборе объектов проверяет его на тип,
и если это Composite - вызывает уже у вложенных объектов такие-же итераторы
таким образом мы пробегаемся рекурсивно по всему объекту

/************************************
Decorator (Декоратор)
-------------------------------------
Нужно динамически подключать к объекту дополнительный функционал,
через ТОТ ЖЕ интерфейс.
Делаем класс-декоратор, ему в конструктор прокидывается исходный объект
и сохраняется в private.
Реализовываем в классе-декораторене интерфейс, в котором до и после вызова
интерфейсного метода у исходного класса описываем доп логику

/************************************
Facade (Фасад)
-------------------------------------
Есть набор разрозненных реализаций или интерфейсов
Нужно упростить работу с ними внешних компонентов системы.
Создаем один объект-фасад
Описываем через его методы взаимодействие со всеми нужными объектами, реализациями.

В итоге мы имеем единственную точку входа во всю сложную логику.
И извне взаимодействией с ней сводится к вызовам методов объекта-фасада

/************************************
Flyweight (Приспособленец)
-------------------------------------
Есть куча однотипных мелких объектов
Они создаются/вызываются в разных местах
И надо оптимизировать расход памяти.
Что б не создавать их каждый раз,
мы сохраняем при первой инициализации
каждый тип объекта в фабрике в private
и дальше если нужен такой-же объект
возвращаем уже сохраненный
(lazy init + factory method)

/************************************
Proxy (Заместитель)
-------------------------------------
Необходимо управлять доступом к объекту так,
чтобы не создавать громоздкие объекты «по каждому требованию».
Либо встроить дополнительную логику, не касаемую самого объекта и т.д.

Берем интерфейс исходного объекта.
Создаем класс-proxy с этим же интерфесом.
внутри в private храним
экземпляр исходного объекта (по умолчанию NULL)
Все внешние взаимодействия происходят через прокси.
в методах прокси уже, при необходимости
создается/вызывается из private
исходный объект.