<?php
/**
 * Стратегия (Strategy) —
 * предназначен для определения семейства алгоритмов,
 * инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
 * Это позволяет выбирать алгоритм путем определения соответствующего класса.
 * Шаблон Strategy позволяет менять выбранный алгоритм
 * независимо от объектов-клиентов, которые его используют.
 *
 * ***************Задача
 * По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм,
 * который следует применить.
 * Если используется правило,
 * которое не подвержено изменениям,
 * нет необходимости обращаться к шаблону «стратегия».
 *
 * ***************Мотивы
 * Программа должна обеспечивать различные варианты алгоритма или поведения
 * Нужно изменять поведение каждого экземпляра класса
 * Необходимо изменять поведение объектов на стадии выполнения
 * Введение интерфейса позволяет классам-клиентам ничего не знать о классах,
 * реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы
 *
 * ***************Способ решения
 * Отделение процедуры выбора алгоритма от его реализации.
 * Это позволяет сделать выбор на основании контекста.
 *
 * ***************Участники
 * Класс Strategy определяет, как будут использоваться различные алгоритмы.
 * Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы.
 * Класс Context использует конкретные классы
 * ConcreteStrategy посредством ссылки
 * на конкретный тип абстрактного класса Strategy.
 * Классы Strategy и Context взаимодействуют с целью
 * реализации выбранного алгоритма
 * (в некоторых случаях классу Strategy требуется посылать запросы классу Context).
 * Класс Context пересылает классу Strategy запрос,
 * поступивший от его класса-клиента.
 *
 * ****************Следствия
 * Шаблон Strategy определяет семейство алгоритмов.
 * Это позволяет отказаться от использования переключателей
 * и/или условных операторов.
 * Вызов всех алгоритмов должен осуществляться
 * стандартным образом (все они должны иметь одинаковый интерфейс).
 *
 * ****************Реализация
 * Класс, который использует алгоритм (Context),
 * включает абстрактный класс (Strategy),
 * обладающий абстрактным методом, определяющим способ вызова алгоритма.
 * Каждый производный класс реализует один требуемый вариант алгоритма.
 *
 * ****************Замечание
 * метод вызова алгоритма не должен быть абстрактным,
 * если требуется реализовать некоторое поведение,
 * принимаемое по умолчанию.
 *
 * ****************Полезные сведения
 * и стратегия, и декоратор может применяться
 * для изменения поведения конкретных классов.
 * Достоинство стратегии в том,
 * что интерфейс кастомизации не совпадает
 * с публичным интерфейсом
 * и может быть куда более удобным,
 * а недостаток в том,
 * что для использования стратегии необходимо
 * изначально проектировать класс
 * с возможностью регистрации стратегий.
 *
 */

class Pattern
{
    static function process()
    {
        if (isset($_SERVER["HTTP_USER_AGENT"]) && strstr($_SERVER["HTTP_USER_AGENT"], "Win"))
            $context = new Context(new ZipFileNamingStrategy());
        else
            $context = new Context(new TarGzFileNamingStrategy());
        $context->execute();
    }
}

interface NamingStrategy
{
    function createName($filename);
}

class ZipFileNamingStrategy implements NamingStrategy
{
    function createName($filename)
    {
        $url = "http://downloads.foo.bar/{$filename}.zip";
        print $url . "\n";
        return $url;
    }
}

class TarGzFileNamingStrategy implements NamingStrategy
{
    function createName($filename)
    {
        $url = "http://downloads.foo.bar/{$filename}.tar.gz";
        print $url . "\n";
        return $url;
    }
}

class Context
{
    private $namingStrategy;
    function __construct(NamingStrategy $strategy)
    {
        $this->namingStrategy = $strategy;
    }
    function execute()
    {
        $url[] = $this->namingStrategy->createName("Calc101");
        $url[] = $this->namingStrategy->createName("Stat2000");

        return $url;
    }
}
Pattern::process();