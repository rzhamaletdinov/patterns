/************************************
Chain of Responsibility (Цепочка обязанностей)
-------------------------------------
Нужно организовать в системе разные
уровни/права ответственности

аналог итератора

делаем абстрактный класс
в нем задаем все уровни реагирования
сравнимыми величинами (#константы с числовыми значениями)
в конструкторе принимаем одну из констант и кладем ее в private
делаем метод public setNext(), принимающий экземпляр абстрактного класса
делаем abstract метод concretProcess()
он реализуется в каждом из наследников, соответствующих конкретному уровню.
делаем метод public process(), который принимает в числе аргументов
константу с уровнем реагирования и
в зависимости от уровня реагирования
выполняем concreteProcess
и если необходимо, переходим на следующий уровень

для использования создаем друг в друге в порядке критичности
нужные наследники и отправляем через первый все сообщения

/************************************
Command (Команда)
-------------------------------------
класс-отправитель комманды и класс-получатель
независят друг от друга напрямую +
Нужно обеспечить обработку команды в виде объекта,
чтобы сохранять её, передавать в качестве параметра, возвращать её,
как и любой другой объект.

Делаем объект, описываем методы
во всех методах класса-отправителя создаем объект команду
с нужными свойствами и делаем все через него

/************************************
Interpreter (Интерпретатор)
-------------------------------------
редко юзаются в пыхе
в языках общего применения -
для очень сложной структуры,
где есть опасность запутаться в куче классов
изменять способ вычисления выражений легче чем менять логику
применимая задача: найти строку по образцу.
(определение эквивалентной строки - и есть вычисление)
АCД интерпретатора – пример паттерна Composite.
Для обхода - паттерн Iterator.
Терминальные символы могут разделяться c помощью Flyweight.
http://habrahabr.ru/post/191252/

/************************************
Iterator (Итератор)
-------------------------------------

Позволяет перебирать объекты не вникая в их сущность.
Применим к массивам, спискам (двусвязным, односвязным),
дереьвьям и т.д.

Храним в итераторе указатель на текущую позици
метод, проверяющий, доступен ли след элемент
метод, перехода к след элементу.

юзая это в цикле while бегаем по объектам

Хитрожопый пример - лаба на С++ с кольцевым двусвязным списком.
(&HeadElement = &TailElement)

/************************************
Mediator (Посредник)
-------------------------------------

/************************************
Memento (Хранитель)
-------------------------------------

/************************************
Observer (Наблюдатель)
-------------------------------------

Если нам надо оповещать несколько объектов о нужных событиях
т.е. что при событии у всех объектов вызывался метод "событие произошло"

Делаем объект-центр(SplSubject)
у него метод "подписаться", "отписаться"
(в них передаем объекты, которые надо оповестить -
они складываются в protected_list внутри Subject)

при определенном событии внутри центра
вызываем метод notify,
который пробегается по всему листу
и вызывает у каждого объекта нужную логику.
тем самым "оповещая" подписанный объект

пример - чат

/************************************
State (Состояние)
-------------------------------------

/************************************
Strategy (Стратегия)
-------------------------------------

/************************************
Template Method (Шаблонный метод)
-------------------------------------

/************************************
Visitor (Посетитель)
-------------------------------------
