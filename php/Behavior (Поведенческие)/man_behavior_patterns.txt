/************************************
Chain of Responsibility (Цепочка обязанностей)
-------------------------------------
Нужно организовать в системе разные
уровни/права ответственности

аналог итератора

делаем абстрактный класс
в нем задаем все уровни реагирования
сравнимыми величинами (#константы с числовыми значениями)
в конструкторе принимаем одну из констант и кладем ее в private
делаем метод public setNext(), принимающий экземпляр абстрактного класса
делаем abstract метод concretProcess()
он реализуется в каждом из наследников, соответствующих конкретному уровню.
делаем метод public process(), который принимает в числе аргументов
константу с уровнем реагирования и
в зависимости от уровня реагирования
выполняем concreteProcess
и если необходимо, переходим на следующий уровень

для использования создаем друг в друге в порядке критичности
нужные наследники и отправляем через первый все сообщения

/************************************
Command (Команда)
-------------------------------------
класс-отправитель комманды и класс-получатель
независят друг от друга напрямую +
Нужно обеспечить обработку команды в виде объекта,
чтобы сохранять её, передавать в качестве параметра, возвращать её,
как и любой другой объект.

Делаем объект, описываем методы
во всех методах класса-отправителя создаем объект команду
с нужными свойствами и делаем все через него

/************************************
Interpreter (Интерпретатор)
-------------------------------------
редко юзаются в пыхе
в языках общего применения -
для очень сложной структуры,
где есть опасность запутаться в куче классов
изменять способ вычисления выражений легче чем менять логику
применимая задача: найти строку по образцу.
(определение эквивалентной строки - и есть вычисление)
АCД интерпретатора – пример паттерна Composite.
Для обхода - паттерн Iterator.
Терминальные символы могут разделяться c помощью Flyweight.
http://habrahabr.ru/post/191252/

/************************************
Iterator (Итератор)
-------------------------------------

Позволяет перебирать объекты не вникая в их сущность.
Применим к массивам, спискам (двусвязным, односвязным),
дереьвьям и т.д.

Храним в итераторе указатель на текущую позици
метод, проверяющий, доступен ли след элемент
метод, перехода к след элементу.

юзая это в цикле while бегаем по объектам

Хитрожопый пример - лаба на С++ с кольцевым двусвязным списком.
(&HeadElement = &TailElement)

/************************************
Mediator (Посредник)
-------------------------------------
Обеспечить взаимодействие множества объектов,
сформировав при этом слабую связанность
и избавив объекты от необходимости явно ссылаться друг на друга.

Делаем аналог observer и работаем через интерфейс mediator
как через посредника

/************************************
Memento (Хранитель)
-------------------------------------
нужен когда:
 = необходимо сохранить снимок состояния объекта
(или его части) для последующего восстановления
 = прямой интерфейс получения состояния объекта
раскрывает детали реализации и нарушает инкапсуляцию объекта

создаем объект хранитель, который хранит состояние объекта
и может его вернуть по запросу.
Таким образом после того как намутил дичь с объектом
можно из Memento забрать объект в оригинальном состоянии
и таким образом восстановить его.

/************************************
Observer (Наблюдатель)
-------------------------------------

Если нам надо оповещать несколько объектов о нужных событиях
т.е. что при событии у всех объектов вызывался метод "событие произошло"

Делаем объект-центр(SplSubject)
у него метод "подписаться", "отписаться"
(в них передаем объекты, которые надо оповестить -
они складываются в protected_list внутри Subject)

при определенном событии внутри центра
вызываем метод notify,
который пробегается по всему листу
и вызывает у каждого объекта нужную логику.
тем самым "оповещая" подписанный объект

пример - чат

/************************************
State (Состояние)
-------------------------------------
во время выполнения программы
объект должен менять свое поведение
в зависимости от своего состояния.

Создаем объект-который должен менять состояние(widget)
Создаем классы кокретных состояний через единый interface
Работаем с ними через методы widget
храним в protected у widget текущее состояние и меняем его
внешне выглядит как будто widget поменял свой класс
/************************************
Strategy (Стратегия)
-------------------------------------
Есть несколько алгоритмов обработки объекта
Они выбираются в зависимости от определенных обстоятельств
Их необходимо инкапсулировать и они должны быть легко взаимозаменяемы

описываем каждый алгоритм как отдельный объект
вызов каждого должен проходить через общий интерфейс

/************************************
Template Method (Шаблонный метод)
-------------------------------------
Есть основа алгоритма и несколько подвидов
конечной реализации

описываем абстрактный класс - шаблон алгоритма
в нем описываем в виде отдельныхъ функций
все шаги алгоритма

далее описываем функцию-process
которая вызывет все эти шаги-функции

делаем наследников этого абстрактного класса
и переопределяем в них нужные функции шаги
непереопределенные остаются без изменений

/************************************
Visitor (Посетитель)
-------------------------------------
